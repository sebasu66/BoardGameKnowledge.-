the word export below the chart and choose a location to save the file.

simULaT inG and BaLancinG Games

177

FIGURe 8.3
a machinations chart
showing the result of
100 runs

Designing Artificial Player Strategies

It often takes several tries to get the strategy for an artificial player right. This is to
be expected, especially if you are creating artificial players for your own designs.
Designing artificial players is a good way to explore and test your design. Ideally,
you should be able to find many valid strategies for your artificial players to follow.
If you can script an artificial player that consistently beats other artificial players (or
yourself), you probably have found a dominant strategy, and you need to change
the mechanics to reduce the effectiveness of that strategy.

remOvinG aLL randOmness
As we discussed in the section “Randomness vs. Emergence” in Chapter 6, “Common
Mechanisms,” random factors can obscure the operation of a pattern that might
create a dominant strategy. When testing for balance, it is important to identify
dominant strategies, and this will be easier to do if you remove the random factors
from the mechanics.

ChAptEr 8

Artificial players cannot replace real players, and the scripting options will not
allow you to create clever artificial intelligence (AI). The purpose of artificial players
is to test relatively simple strategies to see how the mechanics operate, not to build
an adaptive AI player. To get the most out of artificial players and automated play
tests, it is best to design artificial players that represent caricatures: Design them to
consistently follow a particular strategy, no matter the consequences. For example,
if you want to find out what mix of unit types is best for a real-time strategy game,
design a few different artificial players to build the various mixes that you want to
try and have them play each other. Artificial players can be passive or automatic
just like any other node. This allows you to switch between different artificial players quickly and thus try different artificial players simultaneously. While you are
running a diagram, you can click an artificial player to switch it between automatic
and passive modes.

178

Game mechanics: advanced Game desiGn

Randomness that is expressed as a percentage in a Machinations diagram can be easily replaced by substituting a fraction representing the average value. If you have a
source that randomly produces resources with a probability of 20%, you can replace
this number with a fixed production rate of 0.2. This will cause the source to produce
a resource at the rate of two every ten time steps. Randomness that is expressed as
a range generated by rolling multiple dice (such as 3D6) is more difficult to replace
because the probability distribution is not uniform. We suggest using the average.
The formula for the average with any number of dice that all have the same number
of sides is as follows:
Average die roll = (Number of sides on a die +1) × Number of dice ÷ 2
In the case of 3D6, it is (6+1) × 3 ÷ 2, or 10.5.
Alternatively, you might want to make sure that the script of your artificial players
does not involve any randomness. In this case, replace all fireRandom() commands
with fireSequential() commands and find a different value for all conditions that
involve random. For example, if(random < 0.3) fireRandom(A, B, B, C) could be rewritten as if(steps % 10 < 3) fireSequential(A, B, B, C).
If you remove all the randomness in labels on connectors and all the randomness
appearing in artificial player scripts, you will always get the same result from running
the diagram. This might be a good way to find out whether a certain strategy is actually superior to another strategy.

LinKinG arTiFiciaL PLaYers
When working with artificial players, your scripts can get long and complex. One
way to reduce the complexity of the scripts is to split a script over multiple artificial
players. This can be done by having one artificial player firing another, interactive
artificial player. For example, you could create one artificial player called builder that
you design to identify and fire the best building action, while you create another
called attacker to identify and fire the best offensive actions. In that case, you could
randomly select between the two by creating a third artificial player with the script
fireRandom(builder, attacker).
A word of caution, however: Artificial players allow you more control over the
behavior of a Machinations diagram, but this can cause you to mislead yourself
about how well-balanced or manageable your economy is. If you have to spend a
lot of time trying to make artificial players that successfully control your economy,
that’s usually an indication that your economy has a problem. Artificial players
aren’t supposed to be smart enough to beat a game that is unfair to the player or has
other weaknesses. Their purpose is to reveal issues, not to obscure them. Tune your
mechanics, not your artificial players.

simULaT inG and BaLancinG Games

179

Playing with Monopoly
For our first detailed example of an automated Machinations diagram, we will
explore the balance of the game Monopoly. We’ll look at how this balance is affected
by the different mechanisms in the game and how design patterns might be applied
to improve the game.
Figure 8.4 represents a model of Monopoly. It is slightly different from the models
we have used for Monopoly so far. The important differences are as follows:
It represents a two-player game. Earlier in the book we used a source and a drain
to represent the player receiving and paying rent, but this has been replaced by two
gates that transfer money between the two players. In this case, every property that
a player has generates a 4% chance that the other player has to pay one money unit
every time step.

n

The number of available properties is limited. In this example, there are only 20
properties in the game initially stored in the Available pool. Once they are gone, the
players cannot buy more property.

n

FIGURe 8.4

We also defined two artificial players that control each player. Both artificial players
have a simple, single-line script. This script reads as follows:
if((random * 10 < 1) && (Money > 4 + steps * 0.04)) fire(Buy)
The effect is that each artificial player has a 10% chance that it will buy a property in each time step. It will buy property only if it has enough money, however.
Initially the player must have more than four money units in its pool in order to
buy, but this value gradually increases as the game progresses (this is why the steps
value appears in the condition). This condition was added to make sure the artificial
player did not exhaust its money too quickly and lose the game early on. We set

ChAptEr 8

a two-player version
of Monopoly

180

Game mechanics: advanced Game desiGn

it up so that the minimum amount of money the artificial player keeps in its pool
gradually increases, because as more property is bought by each player, the chances
increase that the player will have to pay more rent on consecutive turns. It needs to
keep a larger and larger reserve as time goes on.

Simulated Play-Test Analysis
Running these identical players against each other and tracking the amount of money
that each player has over multiple sessions produces a chart like the one in Figure 8.5.
Reading this chart is not easy, but a few features do stand out. The amount of money
that both players have stays more or less stable for the first 90 steps or so but then
starts to increase gradually. Figure 8.6 highlights this trend. (We added the Trend
line for illustration; it was not generated by the Machinations Tool.) As we discussed
in previous chapters, this trend is the result of the positive feedback that is at the
heart of Monopoly. More importantly, it is typical of the dynamic engine pattern discussed in Chapter 7, “Design Patterns” (see also Appendix B).

FIGURe 8.5
multiple sessions of
simulated play. The
brighter lines are the
most recent run.

FIGURe 8.6
The trend in the
gameplay

To better study this trend, we can remove all randomness from the diagram. This is
done by changing the production rates, the implementation of the rent mechanism,
and the script of the artificial players. Figure 8.7 reflects these changes. The new
script for the deterministic artificial players is as follows:
if((steps % 10 < 1) && (Money > 4 + steps * 0.04)) fire(Buy)

simULaT inG and BaLancinG Games

181

FIGURe 8.7
a deterministic version
of Monopoly

You can see the result of simulated play session in Figure 8.8. The trend is very clear
in this chart. (Note that in this chart the two players completely overlap because they
are following identical strategies, so only one player is visible.) Also note that in this
chart the number of properties owned by each player is represented as a thin line.

FIGURe 8.8

The effects of luck
To study the effects of luck on the game of Monopoly, we then changed the script of
the red player to read as follows:
if((steps % 20 < 1) && (Money > 4 + steps * 0.02)) fire(Buy)
This leads to a situation in which the red player has only half as many opportunities
to buy a new property. Instead of buying every 10 steps, red buys only every 20 steps.
Figure 8.9 displays a chart that reflects these changes. If you look only at the money
lines, the players’ fortunes don’t seem that different initially. However, as any experienced player of Monopoly will tell you, the game is all about getting the properties.
The difference in properties held is the real indication of the players’ strengths.

ChAptEr 8

a simulated play session of deterministic
Monopoly

182

Game mechanics: advanced Game desiGn

FIGURe 8.9
The effect of a consistent difference in luck.
Thick lines are money
owned; thin lines are
properties owned.

Using this chart, we can study the effects of randomizing various mechanics. For
example, Figure 8.10 illustrates the effects of randomizing the time it takes to pass
Go again (by restoring the production rate of that pool to 2/(3+D5), thus 2 every 4
to 8 turns). As you can see, the effects are not that great. Most importantly, it does
not affect the main trend of the game very much. Passing Go doesn’t really influence the game significantly.

FIGURe 8.10
The effect of randomizing how often the
players pass Go

The effects of randomizing the rent mechanism, as shown by Figure 8.11, are
greater. Even so, it does not break the general trend (although if you look at the
chart carefully, you might notice that it sometimes results in red having much less
money and therefore being able to buy fewer properties).

FIGURe 8.11
The effect of randomizing the rent
mechanism

simULaT inG and BaLancinG Games

183

However, randomizing the chance that a player gets the opportunity to buy property
has a far greater effect (Figure 8.12). Most importantly, it affects the distribution of
properties between players and impacts the money distribution as a result. To implement the different opportunities, the script for the blue player reads as follows:
if((random * 10 < 1) && (Money > 4 + steps * 0.02)) fire(Buy)
While the script for the red player reads as follows:
if((random * 20 < 1) && (Money > 4 + steps * 0.02)) fire(Buy)

FIGURe 8.12
The effect of randomizing the opportunity to
buy property

If we put all these effects in a single diagram, the chart looks like the one in Figure
8.13. Note, however, that this chart is different from the first chart of Monopoly
(Figure 8.5), because in this chart the odds are still against the red player. He has
about half as many opportunities to buy a property as the blue player. Also note that
although the fortunes of both players are more varied, red rarely wins.

FIGURe 8.13

Rent and Income balance
One problem with our model of Monopoly is that in most runs the game doesn’t
end in victory for one player, so the Machinations Tool stops the simulation after a
while. One player might get rich because he takes more rent from the other player,
but as long as the other player can compensate for it by passing Go frequently enough,
the game goes on indefinitely. This is because, so far, our model hasn’t implemented
the rent inflation that is built into the real game. Houses and hotels are a critically
important part of Monopoly. They allow the player to invest in his properties, which

ChAptEr 8

all mechanics
randomized

184

Game mechanics: advanced Game desiGn

increases the rent if another player ends a turn on his property. Figure 8.14 adds
this mechanism to the game. In this diagram, players can buy both properties and
houses, which increases their chance to get a bigger payout when receiving rent.

FIGURe 8.14
Monopoly with an
additional mechanism
to buy houses

To allow the artificial players to use the new gameplay option, we used the following script:
if((random * 10 < 1) && (Money > 4 + steps * 0.04)) fire(Buy)
if((Property > Houses / 5) && Money > 6 + steps * 0.04)) fire(Invest)
The first line of the script is just the same as it was: The player has a random 10%
chance of buying a property every time step, if he has enough money saved. The
second line states that if he has more than five times as many properties as houses
(and even more money saved), then he invests in a house.
The best way to see the effect of this balance is to turn the diagram into a deterministic version (removing all random factors), increase the income from passing
Go, and have one artificial player invest in houses and the other not. Without the
option to invest in houses, both players enjoy an identical steady increase of money,
as shown by the purple line in Figure 8.15. But if one player does invest (blue)
while the other does not (red), the one who invests will win.

FIGURe 8.15
The effects of investing
in houses

simULaT inG and BaLancinG Games

185

What we’ve done here is to change the balance between income from passing Go
and costs from paying rent. It’s no longer possible to pass Go enough to cover the
rising rent—even if we set the amount earned by passing Go fairly high. We ran a
nondeterministic diagram 1,000 times in which both players invest in houses, with
an income from Go set to 5/(3+D5). We learned that somebody will win the game
roughly 75% of the time (with an equal chance of either player winning). The other
25% of the time the game drags on until the Machinations Tool stops it. But with
income set to 2/(3+D5), the chances of a game dragging on forever drop to zero.
With a high income and the effects of rent inflation doubled, the chance of entering
an equilibrium is reduced to 2%. The graphs these settings produce in general look
quite interesting (Figure 8.16).

FIGURe 8.16

ChAptEr 8

a better balance
between rent and
income

Adding Dynamic Friction
Our model of Monopoly has now added rent inflation and solved the early problem that passing Go permitted the game to go on forever. However, the power of
property is now actually too high. Having more property than your opponent is
the most significant indicator of who is going to win. This means that the dynamic

186

Game mechanics: advanced Game desiGn

engine pattern in the game is too dominant. Looking through the design patterns in
Appendix B suggests a solution: By applying dynamic friction, the positive feedback
might be kept in check.
We can easily introduce dynamic friction by adding a form of property tax (and
indeed property tax, in a different form, does exist in the board game). At certain
intervals, the player loses money based on the number of properties and/or houses
she has. The new construction is represented in Figure 8.17. The new property tax
mechanism, a drain off each player’s Money pool, is shown with thick lines. It drains
some money (initially set to zero) every six time steps. The amount that it drains
goes up as the player collects property and houses; this is controlled by thick-lined
state connections (dotted lines) from the player’s Houses and Property pools to the
label on the resource connection leading to the Property Tax drain. The tax rate
shown in the diagram is 6% per house and 30% per property.

FIGURe 8.17
Monopoly with a property tax mechanism

Table 8.2 lists the statistics gathered from simulating the game 1,000 times with different settings for the property tax. Blue was programmed to buy 14 properties, and
red to buy 6. The table exhibits a couple of interesting features. With no taxes, blue
has a clear advantage produced by his larger number of properties. As tax rates go
up, however, blue’s advantage decreases. Greater than a certain point, the taxes are
so high that blue’s properties are actually a disadvantage to his economic success,
and blue starts to lose more often than he wins. Set correctly, the taxes do indeed
act as dynamic friction, reducing the effect of positive feedback.
Both artificial players are set to purchase property and houses at the earliest available
opportunity, which might not be the best strategy if property taxes are in operation.
They might do better if they played a bit more conservatively.

simULaT inG and BaLancinG Games

187

Another thing to notice in the table is that the property taxes reduce the number of
“no winner” outcomes. This, too, is a desirable quality in a game: The friction helps
prevent stalemates.
ses

BluE W INS
( B u y s 14 P r o p e r t i e s)

RED WINS
( B u y s 6 P r o p e r t i e s)

inner

no taxes

632

152

216

0.1/0.02

557

314

129

0.2/0.04

472

503

25

0.3/0.06

456

542

2

TAble 8.2
effects of different
Property Tax rate
settings

Balancing SimWar
So far, all the extended examples in this book have been about games that have
already been published. But the Machinations framework is not just a tool for analysis. To demonstrate the framework’s value for designing new games, we will discuss
in detail a game that (to our knowledge) never has been built yet is known to game
design community. This game is SimWar.

FIGURe 8.18
a visual summary of
simWar (Wright, 2003)

ChAptEr 8

SimWar was presented during the Game Developers’ Conference in 2003 by game
designer Will Wright, who is well-known for his published simulation games,
SimCity and The Sims, among many others. SimWar is a hypothetical, minimalistic
war game that features only three units: factories, immobile defensive units, and
mobile offensive units. These units can be built by spending an unspecified resource
that is produced by factories. The more factories a player has, the more resources
become available to build new units. Only offensive units can move around the
map. When an offensive unit meets an enemy defensive unit there is a 50% chance
that one destroys the other, and vice versa. Figure 8.18 is a visual summary of the
game and includes the respective building costs of the three units.

188

Game mechanics: advanced Game desiGn

During his presentation, Wright argued that this minimal real-time strategy game
still presents the player with some interesting choices and displays dynamic behavior
similar to that found in other games within the same genre. Most notably Wright
argued that a rock-paper-scissors mechanism affects the three units: Building factories
trumps building defenses, building defenses trumps building offensive units, and
building offensive units trumps building factories. Wright also describes a shortterm vs. long-term trade-off and a high-risk/high-reward strategy that recalls the
“rush” and “turtle” strategies found in many real-time strategy games (see the sidebar “Turtling vs. Rushing”).

g
Turtling and rushing are two common strategies found in many real-time strategy games.
a turtling player builds up his defenses and production capacity while holding off enemy
attacks; he then tries to use his superior production capacity to build a large attack wave
and overwhelm the opponent’s defenses. in contrast, a rushing player focuses on attacking early in the hope of overwhelming the opposition before they have a chance to dig in.
rushing is generally considered to be a high-risk/high-reward strategy and frequently
requires more skill of the player. To rush successfully, a player must be able to perform
many actions per minute.

Modeling SimWar
In this section, we build a model of SimWar in stages, using Machinations diagrams.
The mechanics we build in each stage follow the same structure as the ones we
offered as real-time strategy examples in Chapter 6.
Starting with the production mechanism, we use a pool (Resources) to represent a
player’s collected resources (Figure 8.19). The pool is filled by another automatic
pool that represents the uncollected resources available to the player. The game’s
production rate is initially 0 but increases by 0.25 for every factory the player builds.
The player can build factories by clicking the interactive converter labeled BuildF,
which will pull resources only when at least five are available. The structure is a
typical implementation of the dynamic engine pattern that we discussed in Chapter
7. Like all dynamic engines, it creates a positive feedback loop: The more factories a
player builds, the quicker resources are produced, which in turn can be used to build
even more factories. However, as the resources are ultimately limited, building only
factories might not be the best idea. Notice that, in this case, the structure requires
players to start with at least five resources already collected or one factory already
built. Otherwise, players can never start producing.

simULaT inG and BaLancinG Games

189

FIGURe 8.19
Factories produce
resources.

Resources are also used to build offensive and defensive units. Figure 8.20 illustrates
the mechanics for this. The diagram uses color-coded resources. The units produced
by the converter labeled BuildD are blue, while the units produced by BuildO are green
as indicated by the color of their respective outputs. This means that blue resources
(representing defensive units) and green resources (representing offensive units) are
both gathered on the Defense pool. However, clicking the Attack pool will pull all green
resources toward it. This way, only offensive units can be used to launch an attack.

FIGURe 8.20
spending resources
to build offensive and
defensive units

Figure 8.21 illustrates how combat between two players is modeled. In each time
step, each attacking unit of one player has a chance to destroy a defending unit of
the other player, and similarly, defending units have a chance to destroy attacking
units. Attacking units also have a chance to destroy enemy factories, but that drain
is active only when the defending player has no defending units left.
attacking and
defending

ChAptEr 8

FIGURe 8.21

190

Game mechanics: advanced Game desiGn

Putting It All Together
Combining the structures of each step, we have a model for a two-player version of
SimWar (Figure 8.22). One player controls the blue (defensive) and green (offensive)
elements on the left side of the diagram, while the other player controls the red
(defensive) and orange (offensive) elements on the right side of the diagram. The
two sides are symmetrical.

FIGURe 8.22
Two-player version of
simWar

Figure 8.23 displays the relative strength of each player as it developed over time
during a simulated session. We chose an arbitrary definition of strength: We gave
five points for each factory owned, plus one for each defensive unit, one for each
offensive unit in reserve, and two for each offensive unit currently attacking. The
chart displays what looks like an interesting and close match. This might suggest a
balanced game, but because both artificial players were following the same strategy,
we cannot jump to that conclusion.

FIGURe 8.23
Two players playing

simULaT inG and BaLancinG Games

191

Defining Artificial Players
If you are looking for a challenge yourself, try to beat our artificial player called
random turtle in a simulated game of SimWar. You can find it on the companion
website (see the “Playing SimWar on the Companion Website” sidebar). This player
follows a turtling strategy: It builds up its defense and factories before building offensive units and launching attacks. Its behavior is determined by the following script:
if(Defense <= 3 + pregen0 * 3) do(BuyD)
if(Factories <= 2 + pregen1 * 3) do(BuyF)
if(Defense > 6 + pregen2 * 3 && random < 0.2) do(Attack)
if(Resources > pregen3 * 4) do(BuyO)
Note that this script uses the pregenerated random values (pregen0—pregen3) in order
to alter its strategies a little every time the simulation runs. It will build between
four and six defensive units first, then build between three and five factories, before
focusing on the attack.

playinG simWar on the companion Website

Fun as it may be to play against the “random turtle” strategy or investigate the data
from having two of those artificial players face each other, it reveals little of the balance of the game. Most strategy games allow for rushing and turtling strategies. The
following script defines our turtling strategy:
if(Defense < 4) fire(BuyD)
if(Factories < 4) fire(BuyF)
if(Defense > 9 && random < 0.2) fire(Attack)
if(Resources > 3) fire(BuyO)
Our turtle strategy gives priority to building four defensive units and four factories
first. After that, it starts building offensive units and starts attacking if it has a total
of ten or more units.

ChAptEr 8

Go to the companion website at www.peachpit.com/gamemechanics and find the section
on simWar. The complete version looks like Figure 8.22 but includes artificial players and
a chart to allow you to see the progress of the game. You can easily modify the artificial
players and the balance tweaks described in the section “Tweaking the Balance.” To
have the diagram play itself automatically, make sure one of each color of artificial player
is activated while playing. To play against an artificial player yourself, simply deactivate
all the artificial players for the color you want to control and click the interactive diagram
nodes yourself. note that the black artificial player is not a competitor. its only function
is to stop the game from running too long in the event of a stalemate.

192

Game mechanics: advanced Game desiGn

The following script defines our rushing strategy:
if(Defense < 3) fire(BuyD)
if(Factories < 2) fire(BuyF)
if(Defense > 5 + steps * 0.05 && random<0.2) fire(Attack)
if(Resources > 1) fire(BuyO)
This script puts far less priority on building factories and defenses. It buys two defenses
and then one factory and then starts producing offensive units. Initially it will try to
launch waves quickly, but as time progresses, it tries to save up for bigger assaults.
Note that, apart from the random factor used to time attacks, the scripts define very
consistent strategies. The artificial players will always follow the same strategy,
whether it is successful or not. Because their behavior is consistent, they are ideal to
determine which strategy is more effective, rushing or turtling. A thousand simulated
runs reveal that the turtling strategy is superior by far: It wins roughly 92% of the
time. What’s more, a large proportion of the wins for the rushing player are the result
of the turtling player running out of resources—which doesn’t occur very often.
N OT E each row gives
the results from 1,000
runs, done automatically. however, the
process of changing
the tweaks required
manually adjusting the
diagram.

Tweaking the balance
Clearly, turtling is too successful in our model of SimWar. To find a better balance,
we can try to tweak several values. We’ll start with changing the production costs
for each unit type. You can find the results for 1,000 simulated runs for each tweak
in Table 8.3.
Surprisingly, these tests show us that increasing the cost for defensive units has little
impact on the balance between rushing and turtling strategies. Only when a defensive unit costs more than an offensive unit, making it a really poor choice, does
the turtle strategy start to lose more frequently than the rushing strategy does. This
leads to the conclusion that the balance between rushing and turtling strategy is
mostly affected by the balance between production and offensive units and little by
the balance between offensive and defensive units. Also notice that increasing the
factory costs initially increases the average game length, but it stabilizes when a factory costs eight or more units. This can be explained by the fact that increasing the
factory cost slows the game down because it takes more time to build up production capacity. At the same time, a very high factory cost favors the rushing strategy,
which tends to win faster than the turtling strategy. At high factory costs, the second effect dominates the first effect.

simULaT inG and BaLancinG Games

wins

wins

t

ime

no tweaks

929

68

3

70.97

defense 1.5

890

105

5

74.27

defense 2.0

660

337

3

77.88

defense 2.5

515

480

5

74.04

Factory 6

844

154

2

78.81

Factory 7

792

204

4

88.07

Factory 8

710

278

12

98.53

Factory 9

568

401

31

107.87

Factory 10

455

509

36

107.61

Offense 1.8

914

83

3

67.77

Offense 1.6

888

112

0

63.86

Offense 1.4

802

198

0

58.31

Offense 1.2

653

347

0

52.33

Offense 1.0

506

494

0

48.33

TWEAk

193

TAble 8.3
effects of Tweaking
Production costs in
simWar

chanGe one thinG at a time and
exaGGerate the chanGes

We can also change the balance between the costs of factories and the costs of
units by increasing or reducing their effects. In this case, we tried different variables
for the factories’ production rates (the number of resources each factory produces)
and the chance that attacking units will destroy defensive ones. We also tried different settings for the initial and total available resources. Table 8.4 lists the effects of
these tweaks.

ChAptEr 8

When balancing a game, it is usually best to try one change at a time. if you change
two things, you can never be sure what change contributed what effect. in addition, it is
usually best to start with a pretty big change first. That way, you are sure that the change
is actually having any effect and moves the balance in the direction that you want it to
move. You can always change the value back to somewhere halfway between the original
and the new situation.

194

Game mechanics: advanced Game desiGn

TAble 8.4
effects of various
Tweaks on the Balance
of simWar

TWEAk

wins

wins

t

ime

no tweaks

929

68

3

70.97

Production rate 0.20

847

152

1

88.99

Production rate 0.15

750

248

2

124.34

Production rate 0.10

396

565

39

208.56

Offensive fire power 30%

919

81

0

65.22

Offensive fire power 35%

863

137

0

59.43

Offensive fire power 40%

811

189

0

56.55

Offensive fire power 45%

755

245

0

56.07

Offensive fire power 50%

627

373

0

51.95

starting resources 4

883

114

3

76.43

starting resources 3

885

114

1

79.26

starting resources 2

877

122

1

84.95

starting resources 1

855

144

1

89.51

starting resources 0

797

200

3

98.73

available resources 110

937

63

0

69.85

available resources 120

949

51

0

69.43

available resources 130

945

55

0

71.11

available resources 200

970

30

0

71.18

available resources 90

911

84

5

73.12

available resources 80

860

125

15

80.82

available resources 70

839

134

27

85.96

The best balance is probably found by applying a combination of these tweaks. For
example, keeping an eye on the average playing time, we opted to reduce the production rate to 0.20, the factory cost to 7, and the offensive power to 35%. With
these mechanics, the two strategies are evenly balanced (in the test run, each won
exactly 500 times!) against an average playing time of 83.02 time steps.

simULaT inG and BaLancinG Games

195

From Model to Game
Balancing a Machinations diagram is a useful exercise, but it doesn’t guarantee that the game you are working on will automatically be balanced as well. A
Machinations diagram represents an abstract perspective on your game. It lacks
detail, and as a result, your real game might behave a little differently. When you
balance a Machinations diagram, you should be aware of these differences. The
closer your game design is to the Machinations diagram, the more likely it is that
your balancing efforts in the Machinations Tool will translate directly to the game.
But remember that Machinations cannot account for peculiarities of human player
behavior (such as bluffing) or the effects of strategic maneuvering in a war game.
However, playing with the balance of a diagram is usually worth the effort, even if
the balance does not translate directly. By spending some time balancing the diagram, you are gaining insights into balancing the real game. As long as the structure
of the diagram matches the structure of the mechanics, you can expect that certain
effects will be similar. For example, finding out that the relative costs of factories
and offensive units in SimWar has a great impact on the balance between turtling
and rushing strategies will help you when you are looking for the right balance in
a full implementation of the game. By running play tests on the diagram, you are
likely to recognize gameplay patterns that will emerge from play testing the full game.

Summary

Monopoly, as always, serves as a good game to analyze. In this chapter, we built a
model of Monopoly that included buying properties and houses and showed how different purchasing strategies changed the balance of the game. We also demonstrated
how to reduce the effect of strong positive feedback produced by the dynamic engine
pattern that generates income from rent by introducing a dynamic friction pattern as
well. For our example, we used a tax on houses and properties.
To end the chapter, we modeled Will Wright’s hypothetical game SimWar and showed
how tweaking its various features over many simulated play tests resulted in differing levels of success for two player strategies, rushing and turtling. This is exactly
the sort of testing you have to do when designing a new internal economy for a
game, which demonstrates the value of Machinations to professional game design.

ChAptEr 8

To balance a game, you must play test it many times, and this can be difficult with
long and complex games. The Machinations Tool lets you simulate play tests rapidly by creating artificial players that execute simple strategies automatically. You
can run hundreds of play tests in a few seconds and collect statistical data to show
whether your game is balanced and how well different strategies work.

196

Game mechanics: advanced Game desiGn

Exercises
1. Change the mechanics of Monopoly (the real board game) so that the game ends
sooner and is better balanced than the original.

2. Define artificial player strategies for Monopoly that reflect a different preference
for buying houses and buying properties, without altering the chances of getting
an opportunity to buy. Can you find one that has a significantly better chance to
beat the artificial player used in our experiments?

3. Hold a competition to find out who can build the best artificial player for
SimWar. You may add multiple artificial players that control one another, but you
may not change the basic structure of the diagram. Alternatively, use the better
balanced settings (production rate 0.20, factory cost 7, offensive fire power 35%)
for this competition.

4. Investigate how different building times for the units in SimWar affect the
balance of that game.

ChAptEr 9
ChAptEr 9

Building Economies
So far, we have been treating the internal economies of games as static structures
that do not change as the game is played. The economy itself can be dynamic, but
its basic structure—the relationships among its elements—never changes. This is
true of many games such as Monopoly, which we’ve used extensively as an example.
But some games allow players to actually build the structure of the economy themselves, by adding new sources and drains, for example. In this chapter, we explore
economy-building games and how you can use the Machinations framework to
design them.

Economy-Building Games
Most, but not all, economy-building games belong to either the construction and
management simulation genre or the strategy genre. Good examples are Civilization,
SimCity, and, to a lesser extent, StarCraft. In these games the player constructs buildings and other edifices (we’ll call them all buildings to avoid ambiguity) in the game
world. Based on their juxtaposition, these buildings establish economic relationships
with each other. The effectiveness of the economy depends on the player’s decisions:
what buildings he built, where he put them, how much infrastructure connects
them together, and so on. The landscape itself also contributes to the economy, and
it is important that players make the best use of it. Civilization and SimCity offer
endless variety, because they come with build-in random world generators. Each
new world creates different challenges and opportunities for the player constructing
an economy.
Goals in economy building tend to be loosely defined, as in SimCity, or are very
long-term and offer many different ways to reach them. Often, players set their own
(intermediate) goals, and for many players, building a stable and growing economy
becomes a goal in its own right. If missions exist at all in these games, they often
consist of a single task: to build an economy that achieves a particular state or exists
within certain limits.
The economies in these games usually start with production of basic resources but
tend to get more complicated quickly. For example, in Civilization, players initially
worry about gathering enough food to feed their cities and collecting enough resources
to build a few defensive units. At a later stage, they need to start producing gold to
finance special buildings and research. The location of the city affects the production rates: Building a city on fertile grasslands increases food production, rivers
increase trade and wealth, while hills and mountains offer the opportunity to build

197

198

Game mechanics: advanced Game desiGn

mines to increase production of buildings and units. Players must find locations to
construct upon that best suit their strategy. A player who wants a strong military will
need to produce more raw materials, while building close to rivers can speed up
trade, wealth, and scientific advancements. The player must consider both long-term
and short-term issues: Cities whose population grows fast will eventually produce
more resources than cities that are located close to interesting resources but far from
fertile soil, which is needed for population growth. Civilization’s default mode of
play randomly generates a landscape (Figure 9.1) for every game the player starts.
Players must make the most of the land they have discovered.

FIGURe 9.1
Civilization V

The diagrams that we used earlier to represent StarCraft and similar real-time strategy games took into account only a single base in which players build every type of
building only once. In reality, players often construct the same building multiple
times. They also start new bases set at different distances from vital sources of gas
and minerals. You can add these options into a Machinations diagram, but that
would complicate it a lot without actually making the structure of the game clearer.
Using the Machinations framework to model more complex games like Civilization
or SimCity in their entirety is daunting. Although many of the individual mechanics
can be easily captured using Machinations diagrams, different sessions require different diagrams because players effectively hook up game elements differently every
time. It simply is impossible to try to make one big Machinations diagram that
manages to capture all these options. To understand and design economy building
games, we need a more flexible way of using Machinations diagrams. To illustrate it,
we’ll analyze one game in more detail: Caesar III.

BUiLdinG ecOnOmies

199

Analyzing Caesar III
ChAptEr 9

The Roman city simulation game Caesar III (Figure 9.2) is a good example of an
economy-building game. In this game, players grow cities in the era of the Roman
Empire. They need to build infrastructure for traffic and water and construct buildings to produce food and other basic resources. To expand the city’s economy, the
player needs residences, workshops, markets, and warehouses. The simulated citizens demand temples, schools, and theaters, and at the same time, the player must
provide security against different types of threats by building prefectures, city walls,
and hospitals. Finally, the player must train soldiers to protect the city from invading barbarians.

FIGURe 9.2
Caesar III

The city’s economy is dominated by a multitude of resources. Farms produce wheat,
fruits, or olives, and clay pits produce clay that can be converted into pottery in
special workshops. Other workshops convert olives into oil, or metal into arms.
The residences the player builds are in constant need of these and other goods.
The better the player can supply these residences, the wealthier their inhabitants
become. This has two advantages. First, wealthier houses can house more people
and generate more labor to operate the farms and workshops (at least initially).
Second, wealthier citizens pay more tax money needed to build more farms, workshops, and residences; to pay the salaries of prefectures that keep the city safe from
crime and fire; or to pay the military to protect the city from invading barbarians.

200

Game mechanics: advanced Game desiGn

In the meantime, players need to build granaries, markets, and warehouses to distribute all these goods effectively over the growing city.
One of the advantages of studying Caesar III is that it makes most of the resource
flows visible. The player has to build roads to connect farms to markets and to connect houses to workshops. She can see people in the game carry goods from one
place to another. New citizens flow into the city from a particular edge of the map
and leave the city on a different side. In Caesar III, the structure of the economy
closely resembles the map of the city.
Figure 9.3 represents the basic economic relationships among some of these elements. The consumption of trade goods in residences triggers the production of
wealth. More wealth has a positive effect on the amount of labor generated and
money generated through taxes. At the same time, wealth drains quickly, creating
an ever-increasing need to supply residences with high-quality trade goods.

FIGURe 9.3
Basic economic relationships in Caesar III ,
with different colors
indicating the flow of
different resources

In the game, the actual connections between all these elements are flexible: A farm
might deliver its crops to a granary, warehouse, or workshop depending on the
needs and the distances to these locations (Figure 9.4). The challenge of Caesar III
is to utilize space effectively and build a smoothly running economy. Players gradually build this economy as they see fit, but it will invariably be dominated by the
positive feedback loop that involves production, consumption by citizens, and tax

BUiLdinG ecOnOmies

201

FIGURe 9.4
a map of the economic
buildings in Caesar III

many more mechanisms
Caesar III includes a few more elements that we have left out for the sake of discussion.
in the real game, players also need to manage a number of hazards such as crime and
fire by constructing special buildings to counter these effects. They serve to complicate the production mechanisms further. apart from nutrition and wealth, the citizens
also demand entertainment, culture, education, and religion, which are produced and
consumed in similar ways. Finally, in most levels of Caesar III, players need to deal with
demands of the roman emperor and to fight invading barbarians. They act as extra, but
intermittent, friction on the economic engine.

ChAptEr 9

income. This positive feedback is balanced by the negative feedback provided by the
dynamic friction built into the residence mechanism (Figure 9.3). The more effective
players are at utilizing space and building up their city, the more effectively their
economic engine will run.

202

Game mechanics: advanced Game desiGn

Dominant economic Structure
To get a better grip on a complex and elusive economy like the one in Caesar III,
we’ll zoom out a little and look at the economy on a more abstract level. Figure 9.5
reveals the dominant economic structure of the game. To build an effective economy,
the player needs to be aware of the feedback loop that exists between residences,
production, and distribution. He must try to invest in such a way that the city produces enough money to keep expanding and paying for its upkeep.



FIGURe 9.5
The dominant economic structure of





Caesar III


 
  






  


 


  

 


  
 
You can find no less than four design patterns implemented in this diagram. The
feedback between residences and economic infrastructure acts as a converter engine
with labor and trade goods forming the production loop. In addition, building
investments follows the engine building pattern because it improves the main converter engine that drives the economy. Investments also activate dynamic friction by
raising salaries and upkeep costs. Therefore, building causes multiple feedback.
The dominant economic structure in Caesar III sets up a template for the ideal economy in the game. The economy a player builds will gravitate toward this structure.
However, planning and building this structure is no trivial task. The game is set up
in a way that simply drawing a map for a perfect city is impossible. There are four
main impediments to building the economy in Caesar III:
The landscape restricts the player. It dictates how much space is available and
dictates the location where certain production buildings can be constructed (a
timber yard must be built close to woods; a marble quarry must be built close to
mountains). Bodies of water restrict movement and the construction of infrastructure. Certain resources simply are not available on a particular map (for example,
olive farms are not available in the British Isles). Each map provides its own unique

n

BUiLdinG ecOnOmies

203

challenges and forces the player to improvise as the circumstances dictate. A building strategy that works in one landscape might not be as effective in another.
The player starts with a limited amount of money to start building. She must
earn the money for further development as she goes along. The player is offered a
loan when she runs out of money, but she has to pay it back or face the wrath of
the Roman emperor (who will eventually send his legions to attack the city). The
economy responds fairly slowly to changes, creating an unpredictable rhythm of
good and bad economic tides (see the “Make Negative Feedback Slow and Durable”
sidebar). A player might get into trouble when crucial buildings collapse or burn
down because she forgot to hire enough prefectures or engineers, locally collapsing
the entire economy.
On many maps, the player can be attacked by invading barbarians, requiring her
to focus both on building and defending the city. Attacks create periodic threats
that increase over time. The player must prepare her defenses in advance, creating
a delicate balance between short-term (making ready for the next attack) and longterm (building up the economy) effects. This adds additional patterns and is more
difficult to manage than a city that is less prone to attack.

n

Certain missions require players to produce large quantities of particular trade
goods to please the emperor. This makes the player dependent on trade with other
cities for vital resources. Such an economy will have sudden, periodic changes in
the number of trade goods in circulation. These rapid shifts can wreak havoc on the
economic balance. The wealthier the city gets, the more delicate the balance that is
required to maintain its wealth.

n

make neGatiVe Feedback sloW and durable
incorporating negative feedback is a good way to create a stable, balanced economy in a
game. however, it can also make a game too easy and too predictable. One design strategy you can use to create a more delicately balanced game economy is to make negative
feedback slower and more durable. For example, consider the diagrams and chart in
Figure 9.6. The black line in the graph shows the setting of the input register; it changes
as the user clicks the register. The negative feedback in the red diagram operates very
fast and creates a stable economy, so the red line in the graph follows the changes in the
input value very quickly. The negative feedback, shown by the blue diagram, is equally
strong, but its effects are delayed: The blue line follows a more unpredictable pattern
as a result of changing input values. The purple diagram also makes the effects more
durable, creating an even more erratic pattern.
continues on next page

ChAptEr 9

n

204

Game mechanics: advanced Game desiGn

make neGatiVe Feedback sloW and durable

continued

FIGURe 9.6 The effects of making negative feedback slower and more durable

building blocks
To further explore the economy of Caesar III, we’ll zoom in on the mechanics of particular buildings and try to understand them in isolation. Figure 9.7 gives detailed
mechanics for four types of buildings that appear in Caesar III: residences, olive
farms, oil workshops, and markets.
The mechanics for residences are just as we presented them in Figure 9.5: Goods
come in and form a pool of wealth, which increases the production rates of both
money and labor, and the goods are also consumed there. If the goods are consumed faster than they come in, the pool is emptied, and the production rates of
money and labor go down.

n

The mechanics for farms provide more details about how labor is used to produce
goods. Labor resources arrive and are delayed for a period. During this period they
set the production of olives from the olive source proportionately to the number
of labor resources in the delay. The olives go into a pool to await being pulled by
something on the outside. The diagram includes a state connection from the delay
to resource connection bringing in labor, whose function is to make sure there are
always six labor resources in the delay at one time. After passing through the delay,
the labor resources are consumed by a drain. (Note that labor resources are not
human beings; they are units of work.)

n

BUiLdinG ecOnOmies

205

Workshops use their labor resources to produce and to collect the resources their
production process requires. Like the olive farm, the oil workshop delays labor
